Проведено емпіричний аналіз часу виконання трьох алгоритмів сортування: злиттям, вставками та Timsort. Результати вимірювань представлені у таблиці.

Аналіз результатів:

1. Сортування злиттям (Merge Sort)

   - Показує гарну продуктивність на великих масивах.
   - Час виконання збільшується майже лінійно, що відповідає його теоретичній складності \(O(n \log n)\).
   - Все ще повільніше за Timsort.

2. Сортування вставками (Insertion Sort)

   - Дуже повільне на великих наборах даних (\(O(n^2)\)).
   - Було протестоване лише на масиві розміром 1000 елементів, де вже показало значно гірший результат.
   - Використовується у Timsort для сортування малих підмасивів.

3. Timsort (sorted в Python)
   - Найшвидший у всіх випадках.
   - Завдяки комбінації сортування злиттям та вставками, алгоритм може працювати за \(O(n \log n)\) на великих наборах і майже за \(O(n)\) на майже відсортованих.
   - Це пояснює, чому Python використовує Timsort за замовчуванням.

Висновки:

- Timsort об’єднує найкращі сторони сортувань злиттям та вставками, що робить його більш ефективним у загальному випадку.
- Програмісти зазвичай використовують вбудовані методи сортування (sorted або .sort()), оскільки вони оптимізовані та швидші за ручну реалізацію.
- На практиці для великих наборів даних краще використовувати сортування \(O(n \log n)\), тоді як сортування вставками підходить лише для дуже малих масивів.
